b' <!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1">  <meta name="description" content="www.paste.org - allows users to paste snippets of text, usually samples of source code, for public viewing."> <meta name="author" content="An Australian"> <link rel="icon" href="/favicon.ico"> <title>Paste code - paste.org</title>  <link href="/assets/themes/bleh/css/github-highlight.css" rel="stylesheet"> <script src="/assets/themes/bleh/js/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();</script> </head> <body> <p><pre><code class="nohighlight">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;typeinfo&gt;\n#include &quot;clsArbolB.h&quot;\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;conio.h&gt;\nusing std::cout;\nusing std::endl;\n \n\nconst int MAX = 4 ;\nconst int MIN = 2 ;\nstruct btnode\n{\n int count ;\n int value[MAX + 1] ;\n btnode *child[MAX + 1] ;\n} ;\nclass btree\n{\n private :\n  btnode *root ;\n public :\n  btree( ) ;\n  void insert ( int val ) ;\n  int setval ( int val, btnode *n, int *p, btnode **c ) ;\n  static btnode * search ( int val, btnode *root, int *pos ) ;\n  static int searchnode ( int val, btnode *n, int *pos ) ;\n  void fillnode ( int val, btnode *c, btnode *n, int k ) ;\n  void split ( int val, btnode *c, btnode *n,\n    int k, int *y, btnode **newnode ) ;\n  void del ( int val ) ;\n  int delhelp ( int val, btnode *root ) ;\n  void clear ( btnode *root, int k ) ;\n  void copysucc ( btnode *root, int i ) ;\n  void restore ( btnode *root, int i ) ;\n  void rightshift ( int k ) ;\n  void leftshift ( int k ) ;\n  void merge ( int k ) ;\n  void show( ) ;\n  static void display ( btnode *root ) ;\n  static void deltree ( btnode *root ) ;\n  ~btree( ) ;\n} ;\n \nbtree :: btree( )\n{\n root = NULL ;\n}\nvoid btree :: insert ( int val )\n{\n int i ;\n btnode *c, *n ;\n int flag ;\n flag = setval ( val, root, &amp;i, &amp;c ) ;\n if ( flag )\n {\n  n = new btnode ;\n  n -&gt; count = 1 ;\n  n -&gt; value[1] = i ;\n  n -&gt; child[0] = root ;\n  n -&gt; child[1] = c ;\n  root = n ;\n }\n}\nint btree :: setval ( int val, btnode *n, int *p, btnode **c )\n{\n int k ;\n if ( n == NULL )\n {\n  *p = val ;\n  *c = NULL ;\n  return 1 ;\n }\n else\n {\n  if ( searchnode ( val, n, &amp;k ) )\n   cout &lt;&lt; endl &lt;&lt; &quot;Key value already exists.&quot; &lt;&lt; endl ;\n  if ( setval ( val, n -&gt; child[k], p, c ) )\n  {\n   if ( n -&gt; count &lt; MAX )\n   {\n    fillnode ( *p, *c, n, k ) ;\n    return 0 ;\n   }\n   else\n   {\n    split ( *p, *c, n, k, p, c ) ;\n    return 1 ;\n   }\n  }\n  return 0 ;\n }\n}\nbtnode * btree :: search ( int val, btnode *root, int *pos )\n{\n if ( root == NULL )\n  return NULL ;\n else\n {\n  if ( searchnode ( val, root, pos ) )\n   return root ;\n  else\n   return search ( val, root -&gt; child[*pos], pos ) ;\n }\n}\nint btree :: searchnode ( int val, btnode *n, int *pos )\n{\n if ( val &lt; n -&gt; value[1] )\n {\n  *pos = 0 ;\n  return 0 ;\n }\n else\n {\n  *pos = n -&gt; count ;\n  while ( ( val &lt; n -&gt; value[*pos] ) &amp;&amp; *pos &gt; 1 )\n   ( *pos )-- ;\n  if ( val == n -&gt; value[*pos] )\n   return 1 ;\n  else\n   return 0 ;\n }\n}\nvoid btree :: fillnode ( int val, btnode *c, btnode *n, int k )\n{\n int i ;\n for ( i = n -&gt; count ; i &gt; k ; i-- )\n {\n  n -&gt; value[i + 1] = n -&gt; value[i] ;\n  n -&gt; child[i + 1] = n -&gt; child[i] ;\n }\n n -&gt; value[k + 1] = val ;\n n -&gt; child[k + 1] = c ;\n n -&gt; count++ ;\n}\nvoid btree :: split ( int val, btnode *c, btnode *n,\n  int k, int *y, btnode **newnode )\n{\n int i, mid ;\n \n if ( k &lt;= MIN )\n  mid = MIN ;\n else\n  mid = MIN + 1 ;\n \n *newnode = new btnode ;\n \n for ( i = mid + 1 ; i &lt;= MAX ; i++ )\n {\n  ( *newnode ) -&gt; value[i - mid] = n -&gt; value[i] ;\n  ( *newnode ) -&gt; child[i - mid] = n -&gt; child[i] ;\n }\n \n ( *newnode ) -&gt; count = MAX - mid ;\n n -&gt; count = mid ;\n \n if ( k &lt;= MIN )\n  fillnode ( val, c, n, k ) ;\n else\n  fillnode ( val, c, *newnode, k - mid ) ;\n \n *y = n -&gt; value[n -&gt; count] ;\n ( *newnode ) -&gt; child[0] = n -&gt; child[n -&gt; count] ;\n n -&gt; count-- ;\n}\nvoid btree :: del ( int val )\n{\n btnode * temp ;\n \n if ( ! delhelp ( val, root ) )\n  cout &lt;&lt; endl &lt;&lt; &quot;Value &quot; &lt;&lt; val &lt;&lt; &quot; not found.&quot; ;\n else\n {\n  if ( root -&gt; count == 0 )\n  {\n   temp = root ;\n   root = root -&gt; child[0] ;\n   delete temp ;\n  }\n }\n}\nint btree :: delhelp ( int val, btnode *root )\n{\n int i ;\n int flag ;\n \n if ( root == NULL )\n  return 0 ;\n else\n {\n  flag = searchnode ( val, root, &amp;i ) ;\n  if ( flag )\n  {\n   if ( root -&gt; child[i - 1] )\n   {\n    copysucc ( root, i ) ;\n    flag = delhelp ( root -&gt; value[i], root -&gt; child[i] ) ;\n    if ( !flag )\n     cout &lt;&lt; endl &lt;&lt; &quot;Value &quot; &lt;&lt; val &lt;&lt; &quot; not found.&quot; ;\n   }\n   else\n    clear ( root, i ) ;\n  }\n  else\n   flag = delhelp ( val, root -&gt; child[i] ) ;\n  if ( root -&gt; child[i] != NULL )\n  {\n   if ( root -&gt; child[i] -&gt; count &lt; MIN )\n    restore ( root, i ) ;\n  }\n  return flag ;\n }\n}\nvoid btree :: clear ( btnode *root, int k )\n{\n int i ;\n for ( i = k + 1 ; i &lt;= root -&gt; count ; i++ )\n {\n  root -&gt; value[i - 1] = root -&gt; value[i] ;\n  root -&gt; child[i - 1] = root -&gt; child[i] ;\n }\n root -&gt; count-- ;\n}\nvoid btree :: copysucc ( btnode *root, int i )\n{\n btnode *temp = root -&gt; child[i] ;\n \n while ( temp -&gt; child[0] )\n  temp = temp -&gt; child[0] ;\n \n root -&gt; value[i] = temp -&gt; value[1] ;\n}\nvoid btree :: restore ( btnode *root, int i )\n{\n if ( i == 0 )\n {\n  if ( root -&gt; child [1] -&gt; count &gt; MIN )\n   leftshift ( 1 ) ;\n  else\n   merge ( 1 ) ;\n }\n else\n {\n  if ( i == root -&gt; count )\n  {\n   if ( root -&gt; child[i - 1] -&gt; count &gt; MIN )\n    rightshift ( i ) ;\n   else\n    merge ( i ) ;\n  }\n  else\n  {\n   if ( root -&gt; child[i - 1] -&gt; count &gt; MIN )\n    rightshift ( i ) ;\n   else\n   {\n    if ( root -&gt; child[i + 1] -&gt; count &gt; MIN )\n     leftshift ( i + 1 ) ;\n    else\n     merge ( i ) ;\n   }\n  }\n }\n}\nvoid btree :: rightshift ( int k )\n{\n int i ;\n btnode *temp ;\n \n temp = root -&gt; child[k] ;\n \n for ( i = temp -&gt; count ; i &gt; 0 ; i-- )\n {\n  temp -&gt; value[i + 1] = temp -&gt; value[i] ;\n  temp -&gt; child[i + 1] = temp -&gt; child[i] ;\n }\n \n temp -&gt; child[1] = temp -&gt; child[0] ;\n temp -&gt; count++ ;\n temp -&gt; value[1] = root -&gt; value[k] ;\n temp = root -&gt; child[k - 1] ;\n root -&gt; value[k] = temp -&gt; value[temp -&gt; count] ;\n root -&gt; child[k] -&gt; child [0] = temp -&gt; child[temp -&gt; count] ;\n temp -&gt; count-- ;\n}\nvoid btree :: leftshift ( int k )\n{\n btnode *temp ;\n \n temp = root -&gt; child[k - 1] ;\n temp -&gt; count++ ;\n temp -&gt; value[temp -&gt; count] = root -&gt; value[k] ;\n temp -&gt; child[temp -&gt; count] = root -&gt; child[k] -&gt; child[0] ;\n temp = root -&gt; child[k] ;\n root -&gt; value[k] = temp -&gt; value[1] ;\n temp -&gt; child[0] = temp -&gt; child[1] ;\n temp -&gt; count-- ;\n for ( int i = 1 ; i &lt;= temp -&gt; count ; i++ )\n {\n  temp -&gt; value[i] = temp -&gt; value[i + 1] ;\n  temp -&gt; child[i] = temp -&gt; child[i + 1] ;\n }\n}\nvoid btree :: merge ( int k )\n{\n btnode *temp1, *temp2 ;\n temp1 = root -&gt; child[k] ;\n temp2 = root -&gt; child[k - 1] ;\n temp2 -&gt; count++ ;\n temp2 -&gt; value[temp2 -&gt; count] = root -&gt; value[k] ;\n temp2 -&gt; child[temp2 -&gt; count] = root -&gt; child[0] ;\n for ( int i = 1 ; i &lt;= temp1 -&gt; count ; i++ )\n {\n  temp2 -&gt; count++ ;\n  temp2 -&gt; value[temp2 -&gt; count] = temp1 -&gt; value[i] ;\n  temp2 -&gt; child[temp2 -&gt; count] = temp1 -&gt; child[i] ;\n }\n for (int i = k ; i &lt; root -&gt; count ; i++ )\n {\n  root -&gt; value[i] = root -&gt; value[i + 1] ;\n  root -&gt; child[i] = root -&gt; child[i + 1] ;\n }\n root -&gt; count-- ;\n delete temp1 ;\n}\nvoid btree :: show( )\n{\n display ( root ) ;\n}\nvoid btree :: display ( btnode *root )\n{\n if ( root != NULL )\n {\n  for ( int i = 0 ; i &lt; root -&gt; count ; i++ )\n  {\n   display ( root -&gt; child[i] ) ;\n   cout &lt;&lt; root -&gt; value[i + 1] &lt;&lt; &quot;\\t&quot; ;\n  }\n  //display ( root -&gt; child[i] ) ;\n  display ( root -&gt; child[root -&gt; count-1] ) ;\n }\n}\nvoid btree :: deltree ( btnode *root )\n{\n if ( root != NULL )\n {\n  for ( int i = 0 ; i &lt; root -&gt; count ; i++ )\n  {\n   deltree ( root -&gt; child[i] ) ;\n   delete ( root -&gt; child[i] ) ;\n  }\n  //deltree ( root -&gt; child[i] ) ;\n  //delete ( root -&gt; child[i] ) ;\n }\n}\n \nbtree :: ~btree( )\n{\n deltree ( root ) ;\n}\n \nvoid main( )\n{\n btree b ;\n int arr[ ] = { 27, 42, 22, 47, 32, 2, 51, 40, 13 } ;\n int sz = sizeof ( arr ) / sizeof ( int ) ;\n for ( int i = 0 ; i &lt; sz ; i++ )\n  b.insert ( arr[i] ) ;\n cout &lt;&lt; &quot;B-tree of order 5:&quot; &lt;&lt; endl ;\n b.show( ) ;\n b.del ( 22 ) ;\n b.del ( 11 ) ;\n cout &lt;&lt; &quot;\\n\\nB-tree after deletion of values:&quot; &lt;&lt; endl ;\n b.show( ) ;\n getch();\n}</code></pre></p> <p align="right"><span style="font-size: 60%">Add a code snippet to your website: <a href="https://www.paste.org" target="_blank">www.paste.org</a></span></p> </body> </html>'